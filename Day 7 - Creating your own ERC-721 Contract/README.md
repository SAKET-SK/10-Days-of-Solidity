- NFTs are now taking the world by storm. They are altering every aspect of our society by monetizing items and services. 
- The massive amount of sales generated by these NFTs via the crypto audience has completely turned the world of digital art and collectibles on its head. 
- With the soaring popularity of digital tokens, various token standards have evolved into existence. 
- Previously we discussed the infamous ERC-20 token and in this tutorial, we are going to guide you to create an ERC-721 contract. 
- Continue reading to find out more about the ERC-721 standard and how to create a smart contract with it.

What is ERC-721 Standard?
- ERC-721 is considered the fabled standard that sparked the NFT mania in the first place. 
- This standard's success stems from a slew of ground-breaking features. It allows you to easily move NFTs across accounts, allowing you to trade these digital tokens for other currencies. 
- Fractional ownership of private property, blockchain ownership of original digital art copies that sell for tens of millions of dollars, and unique avatars that have become a public membership into an elite club are among their initiatives.
- Although it is commonly confused with ERC 20, the former requires basic metadata, such as a name or symbol, as well as a unique id and, in most cases, a URI or Uniform Resource Locator, when creating a contract. ERC 721 is unusual among ERCs in that it is one-of-a-kind and cannot be duplicated due to its unique identifier. 
- The ERC-721 standard made it easier to hold and transfer non-fiduciary tokens within smart contracts. 
- Now that we have brushed up on some basics regarding ERC-721, let's move on to constructing a contract with it.

Creating A Simple ERC-721 Contract with Open Zeppelin:
- In the following tutorial, we are going to make use of Remix as our default IDE for writing, compiling, and deploying the contract. Let's get started now
- Head over to Remix and create a new file named "HelloNFT.sol". This is where we will write our smart contract
- Before initializing the code, we have to define the Solidity compiler version for our contract by using pragma along with the underlying license:

```
// SPDX-License-Identifier:UNLICENSED

pragma solidity ^0.8.9;
```

- After declaring the Solidity compiler version, we move on to import the appropriate Open Zeppelin libraries, notably ERC721, from their official source.
- The ERC721 library contains the fundamental definitions required for a contract to be considered ERC-721 compliant.

```
import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
```

- We will name our contract Hellonftand declare it as ERC-721 compliant along with defining the symbol as HNFT

```
contract Hellonft is ERC721("HelloNft", "HNFT") {
```

- Next, we initialize the tokenId( unique identifier for each token) to 0

```
uint tokenId;
```

- We create a mapping with address as the key and tokenMetaData as the value.

```
mapping(address=>tokenMetaData[]) public ownershipRecord;
```

- The tokenMetaData struct is designed to hold each token's tokenId, timestamp, and tokenURI in one place so that they may be linked to the ownershipRecord of addresses in a complete fashion.

```
struct tokenMetaData {
	uint tokenId;
	uint timeStamp;
	string tokenURI;
}
```

- Now we begin writing our mintToken function. Minting enables us to tokenize various assets. We mint the sample image in the .png format.

```
function mintToken(address recipient, string memory url) public {
```

- We now use the _safeMint method to initiate the minting process imported from the ERC721 contract and push the tokenMetaData to the receiver to maintain our own ownershipRecords. 
- We've hardcoded the same.png file as the URI for minting any token in our contract to make things simple.

```
_safeMint(recipient, tokenId);
        ownershipRecord[recipient].push(tokenMetaData(tokenId, block.timestamp, url));
        tokenId = tokenId + 1;
    }
}
```

- Now you can move on towards deploying this contract on any test net including Remix, the complete contract should look like this now:

```
// SPDX-License-Identifier:UNLICENSED

pragma solidity ^0.8.9;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";

contract Hellonft is ERC721("HelloNft", "HNFT") {
    uint tokenId;
    mapping(address=>tokenMetaData[]) public ownershipRecord;

    struct tokenMetaData {
        uint tokenId;
        uint timeStamp;
        string tokenURI;
    }

    function mintToken(address recipient, string memory url) public {
        _safeMint(recipient, tokenId);
        ownershipRecord[recipient].push(tokenMetaData(tokenId, block.timestamp, url));
        tokenId = tokenId + 1;
    }
}
```

- After calling in the mintToken function you will have successfully tokenized your very first NFT

Final Thoughts:
- We walked you through the process of constructing your own NFT ERC-721 contract using Open Zeppelin in this tutorial. 
- This post also lets you brush up on the foundations and essentials of the most common token standards, as well as the reasons for their growing popularity. 
- We hope this information was helpful in creating your first NFT smart contract. Keep a positive attitude and, as always, Happy Coding!




